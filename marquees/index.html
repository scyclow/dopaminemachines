<!--
NAMES
  Marquees
  Dopamine Machines
  All Sizzle No Steak
  Style Over Substance
  Hottest Art Around
  Too Good To Be True
  Things Are Moving Fast
  Generational Wealth
  Pump + Dump
  Everyone's A Winner
  Pay Attention
  Hypermedia
  What You See Is What You Get


Themes:
  nausia
  advertisements
  the stripped down illusion of two dimensions pretending to be three dimensions
  meaninglessness
  overwhelming
  attention grabbing
  commodification
    - everything is put into a box
    - feelings and broad categories are boiled down to symbols and slogans



TODO
  - figure out text sizing for animation sections
  - off kilter layouts should either have borders around sections or visible overflow
  - all spinning should spin at different rates
    OR use standard component animations on sections
  - be smarter with arrows
  - marquees with high rSpan should generally be slower
    Maybe the smaller rSpan marquees should be faster
  - should have text shadow with border bg (otherwise can't read text)
  - maybe Pointers easter egg with animation grid section
  - layouts with high degree of density look the best -- shoudl make those more common
  - animation sections should have visible overflow sometimes
  - small rSpan shouldn't have backgrounds




















Concept:
  - some mints are "the NFT"
  - other mings are web pages trying to sell the NFTs
  - sales pages take to form of CTA style adverts, news articles, social media pages, etc. -- each one linking to either each other or a target NFT
  - in all, each mint in the collection serves to hype itself up. a self-referential propaganda machine


  this NFT is HOT HOT HOT!🔥
  this NFT will moon🌛
  Don't be a sucker🍬



Things are moving fast, and if you want to make the most of this opportunity you need to pounce on it. Don't wait. Act Now. These deals won't last.





By using this website you agree to the terms...


Best viewed in Chrome X.X.XXX





TODO
  when viewed headlessly, maybe add a fake address bar to the thumbnail



MARQUEES TODO
  - generally slow down, espescially the slimmer ones
  - have more single grid components animate (instead of all of them animating)
  - split emojis up into better categories



 -->

<!DOCTYPE html>
<html translate="no" lang="en" class="notranslate">
<head>
  <meta charset="utf-8">
  <meta name="google" content="notranslate" />
  <title>$$$</title>
    <script>
      function genTokenData(projectNum) {

        const tokenId = String(projectNum * 1000000 + Math.floor(Math.random() * 1000))
        let hash = '0x'
        if (window.location.search.includes('?hash=')) {
          hash = window.location.search.slice(6)
        } else {
          for (let i = 0; i < 64; i++) {
            hash += Math.floor(Math.random() * 16).toString(16)
          }
          window.location.hash = '#' + hash

          const last10hashes = JSON.parse(localStorage.getItem('last10Hashes')) || []
          last10hashes.unshift(hash)

          localStorage.setItem('last10Hashes', JSON.stringify(last10hashes.slice(0, 10)))
        }
        return {
          hash,
          // hash: '0xfeff8806ffe0ff004900b6104392c062d40f238839029c82ed000ffff3cb2003',
          tokenId
        }
      }

      const tokenData = genTokenData(999)
      console.log(tokenData.hash)
    </script>

</head>
<body>

</body>

<script src="./utils.js"></script>
<script src="./sound.js"></script>
<script src="./$.js"></script>
<script src="./globals.js"></script>
<script src="./components.js"></script>
<script src="./text.js"></script>


<script>

  function sectionContainer(child, rSpan, cSpan, h, txtH, onclick) {
    const bwc = prb(0.5) ? { bg: '#000', text: '#fff' } : { bg: '#fff', text: '#000' }
    const txtColor = bw ? bwc.text : `hsl(${txtH}deg, ${sat}%, 50%)`
    const bgColor = bw ? bwc.bg : getBgColor(h)


    const rotation = threeDRotations
      ? `perspective(500px) rotate3d(1,1,1,${lineRotation()}deg)`
      : `rotate(${lineRotation()}deg)`

    const fontStyle = prb(italicRate) ? 'italic' : 'none'


    const borderWidth = min(rSpan, cSpan) * .05

    const container = $.div(
      withBgAnimation(child, rSpan, cSpan),
      {
        class: `sectionContainer ${sectionAnimation}${rotateColor ? ' fullColorRotate' : ''}`,
        style: `
          border-style: ${borderStyle()};
          ${showBorder ? `border-width: ${borderWidth}vmin; box-sizing: border-box;` : 'border-width: 0;'}
          grid-column: span ${cSpan};
          grid-row: span ${rSpan};
          background: ${hideBg ? 'none' : bgColor};
          color: ${txtColor};
          transform: ${rotation};
          font-style: ${fontStyle};
          animation-delay: -${rnd(5)}s;
          animation-direction: ${rotateColor ?'normal' : animationDirection()};
          animation-duration: ${rotateColor ? '25' : animationDuration()}s;
        `
      }
    )

    container.onclick = onclick
    return container
  }


  function marqueeContainter(rSpan, cSpan) {
    const child = sample(content)
    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const slow = 1 + child.innerHTML.length/9
    const h = chooseHue()
    const txtH = chooseAltHue(h)


    // const slowIx = child.indexOf('slow="')
    // slowIx !== -1 ? Number(child.slice(slowIx+6, slowIx+9)) : 1

    const canShowAltAnimation = rSpan >= 2 && cSpan/rSpan >= 6 && child.innerHTML.length < 8
    const sideways = prb(sidewaysPrb) && cSpan/rSpan < 1.2

    const msgAnimation = prb(marqueeAnimationRate) && canShowAltAnimation
      ? chance(
        [1, growShrinkShort],
        [1, vSirenShort],
        [1, dance],
        [1, spin],
        [1, hSiren],
        [1, hPivot],
        [1, hFlip],
        [1, blink],
      )
      : iden

    const r = rnd(750, 1500)
    const duration = rnd(0.5, 100) * slow * speed
    const delay = rnd(duration/2) + (duration / 3)

    const childEl = canShowAltAnimation && prb(0.1)
        ? leftRight(child, {
          style: `font-size: ${height}`,
          duration: r * slow * speed,
          delay: rnd(2000)
        })
        : marquee(child, {
          style: `
            font-size: ${sideways ? width : height};
            text-shadow: ${getShadow(txtH)};
          `,
          direction: posOrNeg(),
          delay,
          duration,
          sideways,
          msgAnimation
        })


    return sectionContainer(childEl, rSpan, cSpan, h, txtH, () => {
      utter(child.innerHTML, 30, 7)
    })
  }

  function animationContainer(rSpan, cSpan) {
    const child = sample(content)
    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const h = chooseHue()
    const txtH = chooseAltHue(h)

    const animation = sample([
      dance,
      growShrink,
      spin,
      hSiren,
      vSiren,
      hPivot,
      vPivot,
      vFlip,
      hFlip,
      updown,
      wave,
      climb,
    ])

    const words = child.innerHTML.split(' ')
    const shortest = words.reduce((shortest, word) => word.length < shortest.length ? word : shortest , words[0])

    const rowSizeMax = 5.5/(child.innerHTML.length)
    const colSizeMax = 7 *(cSpan/(cols*shortest.length))

    const fontAdj = (
      emojiList.includes(child.innerHTML)
        ? 1
        : min(colSizeMax, rowSizeMax)
    ) * (animation === vPivot ? 0.5 : 1)

    const secondAnimation = prb(0.75) ? iden : sample([
      dance,
      growShrink,
      spin,
      hSiren,
      vSiren,
      hPivot,
      vPivot,
      vFlip,
      hFlip,
      updown,
      wave,
      climb,
    ])

    const primaryAnimationParams = {
      delay: rnd(3500),
      duration: 5000
    }
      rnd(750, 5000)


    const childEl = $.div(
      // vFlip(child.cloneNode(true), primaryAnimationParams),
      secondAnimation(
        animation(child.cloneNode(true), primaryAnimationParams),
        {
          delay: rnd(3500),
          duration: rnd(750, 5000)
        }
      ),
      {
        style: `
          font-size: ${fontAdj*100*min(rSpan/rows, cSpan/cols)}vmin;
          text-shadow: ${getShadow(h)};
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
        `,
      }
    )
    // console.log(childEl, animation(child))

    return sectionContainer(childEl, rSpan, cSpan, h, txtH, () => {
      if (animation === spin) {
        smoothSound(primaryAnimationParams)
      } else if ([growShrink, vPivot, hPivot].includes(animation)) {
        growShrinkSound(primaryAnimationParams)
      }
      // flipSound(primaryAnimationParams)
    })
  }


  function getEmojiGrid(rSpan, cSpan) {
    const divisor = rndint(1, min(rSpan/2, cSpan/2))
    return [
      max(1, int(rSpan/divisor)),
      max(1, int(cSpan/divisor))
    ]
  }

  function animationGridContainer(rSpan, cSpan) {
    const child = sample(content.filter(e => emojiList.includes(e.innerHTML)))

    if (!child) return animationContainer(rSpan, cSpan)

    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const h = chooseHue()
    const txtH = chooseAltHue(h)

    const animation = chance(
      [5, growShrink],
      [4, spin],
      [3, blink],
      [3, vSiren],
      [3, hSiren],
      [3, vFlip],
      [3, hFlip],
      [1, dance],
      [1, wave],
      [1, climb],
    )

    const [r, c] = getEmojiGrid(rSpan, cSpan)


    // const words = child.innerHTML.split(' ')
    // const shortest = words.reduce((shortest, word) => word.length < shortest.length ? word : shortest , words[0])

    // const rowSizeMax = 5.5/(child.innerHTML.length)
    // const colSizeMax = 7 *(cSpan/(cols*shortest.length))

    // const fontAdj = (
    //   emojiList.includes(child.innerHTML)
    //     ? 1
    //     : min(colSizeMax, rowSizeMax)
    // ) * (animation === vPivot ? 0.5 : 1)

    // const secondAnimation = prb(0.75) ? iden : sample([
    //   dance,
    //   growShrink,
    //   spin,
    //   hSiren,
    //   vSiren,
    //   hPivot,
    //   vPivot,
    //   vFlip,
    //   hFlip,
    //   updown,
    //   wave,
    //   climb,
    // ])

    const duration = rnd(750, 5000)
    const delayFactor = rnd(0.5, 2)
    const childEl = $.div(
      times(r*c, i => animation(child.cloneNode(true), {delay: (i/(r*c))*duration*delayFactor, duration })),
      {
        class: 'animationGridContainer',
        style: `
          font-size: ${100*min(rSpan/rows, cSpan/cols)/min(r, c)}vmin;
          text-shadow: ${getShadow(h)};
          height: ${100*rSpan/rows}vh;
          width: ${100*cSpan/cols}vw;
          display: grid;
          align-items: center;
          justify-items: center;
          grid-template-rows: repeat(${r}, 1fr);
          grid-template-columns: repeat(${c}, 1fr);
        `,
      }
    )

    return sectionContainer(childEl, rSpan, cSpan, h, txtH)
  }




  function flexSection(rowCells, colCells) {
    let rCursor = 0

    const cells = {}
    times(rowCells, r => cells[r] = [])

    const findNextFilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (cells[rC][c]) return c
      }
      return colCells
    }

    const findNextUnfilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (!cells[rC][c]) return c
      }

      return colCells
    }

    const marquees = []

    const colMax = prb(0.05) ? 3 : colCells
    const colMin = 12

    const rowMin = chance(
      [3, sample([24, 48])],
      [3, sample([6, 8, 12, 16])],
      [1, sample([2, 3, 4])],
      [1, 1],
    )
    const rowMax = prb(0.85) ? rowCells : rowMin


    while (rCursor < rowCells) {
      let cCursor = findNextUnfilledCol(rCursor, 0)

      while (cCursor < colCells) {
        const colsLeft = min(findNextFilledCol(rCursor, cCursor) - cCursor, colMax)
        const rowsLeft = min(rowCells - rCursor, rowMax)

        let cSpan = rndint(min(colMin, colsLeft), colsLeft)
        if (colsLeft - cSpan < colMin) cSpan = colsLeft

        const rSpan = rndint(min(rowMin, rowsLeft), max(1, rowsLeft))

        const aspectRatio = cSpan / rSpan

        marquees.push(
          aspectRatio < 1.25 && aspectRatio > 0.8 ?
            prb(0.25) ? animationContainer(rSpan, cSpan) : animationGridContainer(rSpan, cSpan) :

          aspectRatio < 2 && aspectRatio > 0.5 && prb(0.5) ?
            animationContainer(rSpan, cSpan) :

          marqueeContainter(rSpan, cSpan)
        )

        times(rSpan, r =>
          times(cSpan, c =>
            cells[rCursor+r][cCursor+c] = 1
          )
        )

        cCursor = findNextUnfilledCol(rCursor, cCursor + cSpan)
      }

      rCursor++
    }

    return $.section(
      marquees,
      {
        style: `
          width: ${100*colCells/cols}vw;
          height: ${100*rowCells/rows}vh;
          overflow: hidden;
          grid-row: span ${rowCells};
          grid-column: span ${colCells};
          display: grid;
          grid-template-rows: repeat(${rowCells}, 1fr);
          grid-template-columns: repeat(${colCells}, 1fr);
        `
      }
    )
  }




  setMetadata(content.map(c => c.innerHTML).join(' '))



  const main = $.main(
    [
      flexSection(rows, cols)
    ],
    {
      id: 'main',
      style: `
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: grid;
        grid-template-rows: repeat(${rows}, 1fr);
        grid-template-columns: repeat(${cols}, 1fr);
      `
    }
  )





  $.render($body, main)


</script>
</html>