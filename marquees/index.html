<!--
Things are moving fast, and if you want to make the most of this opportunity you need to pounce on it. Don't wait. Act Now. These deals won't last.





By using this website you agree to the terms...


Best viewed in Chrome X.X.XXX





TODO
  when viewed headlessly, maybe add a fake address bar to the thumbnail



MARQUEES TODO
  - generally slow down, espescially the slimmer ones
  - have more single grid components animate (instead of all of them animating)
  - split emojis up into better categories



 -->

<!DOCTYPE html>
<html translate="no" lang="en" class="notranslate">
<head>
  <meta charset="utf-8">
  <meta name="google" content="notranslate" />
  <title>$$$</title>
    <script>
      function genTokenData(projectNum) {

        const tokenId = String(projectNum * 1000000 + Math.floor(Math.random() * 1000))
        let hash = '0x'
        if (window.location.search.includes('?hash=')) {
          hash = window.location.search.slice(6)
        } else {
          for (let i = 0; i < 64; i++) {
            hash += Math.floor(Math.random() * 16).toString(16)
          }
          window.location.hash = '#' + hash

          const last10hashes = JSON.parse(localStorage.getItem('last10Hashes')) || []
          last10hashes.unshift(hash)

          localStorage.setItem('last10Hashes', JSON.stringify(last10hashes.slice(0, 10)))
        }
        return {
          hash,
          // hash: '0xfeff8806ffe0ff004900b6104392c062d40f238839029c82ed000ffff3cb2003',
          tokenId
        }
      }

      const tokenData = genTokenData(999)
      console.log(tokenData.hash)
    </script>

</head>
<body>

</body>

<script src="./utils.js"></script>
<script src="./$.js"></script>
<script src="./globals.js"></script>
<script src="./components.js"></script>
<script src="./text.js"></script>


<script>




  function marqueeContainer(rSpan, cSpan, rows, cols) {
    const h = chooseHue()
    const sideways = prb(sidewaysPrb) && cSpan/rSpan < 1.2
    const txtH = chooseAltHue(h)
    const shadowH = (h + 90) % 360
    const shadow2H = (h + 270) % 360
    const bwc = prb(0.5) ? { bg: '#000', text: '#fff' } : { bg: '#fff', text: '#000' }
    const bgColor = bw ? bwc.bg : getBgColor(h)
    const txtColor = bw ? bwc.text : `hsl(${txtH}deg, ${sat}%, 50%)`
    const shadowColor = `hsl(${shadowH}deg, ${sat}%, 20%)`
    const shadow2Color = `hsl(${shadow2H}deg, ${sat}%, 50%)`
    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`

    const shadows =
      shadowType === 1 ? `
          0.025em 0.025em ${shadowColor},
          -0.025em 0.025em ${shadowColor},
          0.025em -0.025em ${shadowColor},
          -0.025em -0.025em ${shadowColor},
          0.025em 0 ${shadowColor},
          -0.025em 0 ${shadowColor},
          0 -0.025em ${shadowColor},
          0 0.025em ${shadowColor},
          0 0 0.1em ${shadowColor}
      ` :

      shadowType === 2 ?
        `calc(1vh/${rows}) calc(1vh/${rows}) ${shadowColor}` :

      shadowType === 3 ?
        `0.1em 0.1em ${shadowColor}` :

      shadowType === 4 ?
        `0.05em 0.05em ${shadowColor}, 0.1em 0.1em ${shadow2Color}` :

      shadowType === 5 ?
        `0 0 0.05em ${shadowColor}`

      : '0 0 0'


    const child = sample(content)
    const slowIx = child.indexOf('slow="')
    const slow = slowIx !== -1 ? Number(child.slice(slowIx+6, slowIx+9)) : 1
    const rotation = threeDRotations
      ? `perspective(500px) rotate3d(1,1,1,${lineRotation()}deg)`
      : `rotate(${lineRotation()}deg)`

    const fontStyle = prb(italicRate) ? 'italic' : 'none'


    const childText = $.span(child, {
      style: `text-shadow: ${shadows}`
    })

    const marq = marquee(childText, {
      direction: posOrNeg(),
      delay: rnd(-1000, 0),
      duration: rnd(0.01, 2) * slow * speed,
      sideways
    })

    return $.div(
      marq,
      {
        class: `${animation} ${rotateColor ? 'fullColorRotate' : ''} marquee-container`,
        style: `
          border-style: ${borderStyle()};
          ${showBorder ? 'border-width: 0.03em; box-sizing: border-box;' : 'border-width: 0;'}
          grid-column: span ${cSpan};
          grid-row: span ${rSpan};
          background: ${hideBg ? 'none' : bgColor};
          color: ${txtColor};
          font-size: ${sideways ? width : height};
          transform: ${rotation};
          font-style: ${fontStyle};
          animation-delay: -${rnd(5)}s;
          animation-direction: ${rotateColor ?'normal' : animationDirection()};
          animation-duration: ${rotateColor ? '25' : animationDuration()}s;
        `
      }
    )
  }





  function flexComponent(rowCells, colCells) {
    let rCursor = 0

    const cells = {}
    times(rowCells, r => cells[r] = [])

    const findNextFilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (cells[rC][c]) return c
      }
      return colCells
    }

    const findNextUnfilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (!cells[rC][c]) return c
      }

      return colCells
    }

    const marquees = []

    const colMax = prb(0.05) ? 3 : colCells
    const colMin = 12
    // chance(
    //   [1, cols/3],
    //   [3, cols/4],
    //   [3, cols/5],
    //   [1, int(cols/6)],
    // )
    const rowMax = prb(0.25) ? rowCells : min(4, rowCells)
    const rowMin = chance(
      [3, rows],
      [3, int(rows/rnd(2, 5))],
      [3, int(rows/rnd(5, 24))],
      [1, 1],
    )


    while (rCursor < rowCells) {
      let cCursor = findNextUnfilledCol(rCursor, 0)

      while (cCursor < colCells) {
        const colsLeft = min(findNextFilledCol(rCursor, cCursor) - cCursor, colMax)
        const rowsLeft = min(rowCells - rCursor, rowMax)

        let cSpan = rndint(min(colMin, colsLeft), colsLeft)
        if (colsLeft - cSpan < colMin) cSpan = colsLeft

        const rSpan = rndint(min(rowMin, rowsLeft), max(1, rowsLeft))

        marquees.push(marqueeContainer(rSpan, cSpan, rows, cols))

        times(rSpan, r =>
          times(cSpan, c =>
            cells[rCursor+r] ? cells[rCursor+r][cCursor+c] = 1 : console.log(rowCells, rCursor, r)
          )
        )

        cCursor = findNextUnfilledCol(rCursor, cCursor + cSpan)
      }

      rCursor++
    }

    return $.div(
      marquees,
      {
        style: `
          width: ${100*colCells/cols}vw;
          height: ${100*rowCells/rows}vh;
          overflow: hidden;
          grid-row: span ${rowCells};
          grid-column: span ${colCells};
          display: grid;
          grid-template-rows: repeat(${rowCells}, 1fr);
          grid-template-columns: repeat(${colCells}, 1fr);
        `
      }
    )
  }




  /*
    Potential layouts

    Quarter components
      [Q || dynamic] [Q || dynamic]
      [Q || dynamic] [Q || dynamic]

    News Layout
      [H              ]
      [content  ][  Ad]
      [content  ][  Ad]
      [content  ][  Ad]

    Social Layout



    news component
    <container width/height based on grid>
      <header width/height based on content></header>
      <content fills remaining space></content>
    </container>



    quarter components
      grid of emojis/symbols, size wave
      grid of emojis/symbols, rotating wave
      one big emoji/symbol, grow/shrink
      emoji(s)/symbol(s) bounce around
      single emoji/symbol rotating


    marquee varient
      if r > c
        bounce left<>right
      if c > r
        bounce up<>down


  */


  // function wordLayout() {
  //   let rCursor = 0

  //   const cells = {}
  //   times(rows, r => cells[r] = [])

  //   const findNextFilledCol = (rC, cC) => {
  //     for (let c = cC; c < cols; c++) {
  //       if (cells[rC][c]) return c
  //     }
  //     return cols
  //   }

  //   const findNextUnfilledCol = (rC, cC) => {
  //     for (let c = cC; c < cols; c++) {
  //       if (!cells[rC][c]) return c
  //     }

  //     return cols
  //   }


  //   const components = [
  //     $.div('Header Text', {
  //       style: `
  //         grid-column: span 10;
  //         grid-row: span ${int(rows/2)};
  //         background-color: red;
  //       `
  //     })
  //   ]
  //   times(int(rows/2), r =>
  //     times(10, c =>
  //       cells[r][c] = 1
  //     )
  //   )






  //   while (rCursor < rows) {
  //     let cCursor = findNextUnfilledCol(rCursor, 0)

  //     while (cCursor < cols) {
  //       const colsLeft = min(findNextFilledCol(rCursor, cCursor) - cCursor, colMax)
  //       const rowsLeft = min(rows - rCursor, rowMax)

  //       const cSpan = rndint(min(3, colsLeft), colsLeft)
  //       const rSpan = rndint(min(3, rowsLeft), max(1, rowsLeft))

  //       components.push(marqueeContainer(cSpan, rSpan, 100))

  //       times(rSpan, r =>
  //         times(cSpan, c =>
  //           cells[rCursor+r][cCursor+c] = 1
  //         )
  //       )

  //       cCursor = findNextUnfilledCol(rCursor, cCursor + cSpan)
  //     }

  //     rCursor++
  //   }

  //   return $.main(
  //     components,
  //     {
  //       id: 'main',
  //       style: `
  //         height: 100vh;
  //         width: 100vw;
  //         overflow: hidden;
  //         display: grid;
  //         grid-template-rows: repeat(${rows}, 1fr);
  //         grid-template-columns: repeat(${cols}, 1fr);
  //       `
  //     }
  //   )
  // }


  setMetadata()



  const main = $.main(
    flexComponent(rows, cols),
    {
      id: 'main',
      style: `
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: grid;
        grid-template-rows: repeat(${rows}, 1fr);
        grid-template-columns: repeat(${cols}, 1fr);
      `
    }
  )


  $.render($body, main)









</script>
</html>