<!--
NAMES
  Marquees
  Dopamine Machines
  All Sizzle No Steak
  Style Over Substance
  Hottest Art Around
  Too Good To Be True
  Things Are Moving Fast
  Generational Wealth
  Pump + Dump
  Everyone's A Winner
  Pay Attention
  Hypermedia
  What You See Is What You Get
  hyperzones



Themes:
  nausia
  advertisements
  the stripped down illusion of two dimensions pretending to be three dimensions
  meaninglessness
  overwhelming
  attention grabbing
  commodification
    - everything is put into a box
    - feelings and broad categories are boiled down to symbols and slogans
  desire
  loss of meaning through repetition
  dopamine
  the mechanical and disconnected nature of modenr life
  rube goldberg machines
  gamification of capitalism
  pandering
  the blending of art and capitalism/advertisements
  hyperreality
  hypnosis of media
  symbols
  oversaturation


TODO
  - figure out text sizing for animation sections
  - off kilter layouts should either have borders around sections or visible overflow
  - all spinning should spin at different rates
    OR use standard component animations on sections
  - be smarter with arrows
  - marquees with high rSpan should generally be slower
    Maybe the smaller rSpan marquees should be faster
  - should have text shadow with border bg (otherwise can't read text)
  - maybe Pointers easter egg with animation grid section
  - layouts with high degree of density look the best -- shoudl make those more common
  - animation sections should have visible overflow sometimes
  - small rSpan shouldn't have backgrounds
  - for blinking sections, ensure at least 1 or two have delays >= 0
  - should have way fewer tall/thin horizontal marquees -- really, only if 3D askew or all slim
  - border bgs should have color schemes other than rainbow
  - key to hide mouse
  - key to play all sounds
  - countdown clock (x minutes from load, x minutes until set time in the future)
  - hFlip should be slower
  - animating flame shadows
  - maybe instead of 2d/3d askew, just implement slow section animations
  - maybe with section animations or askew sections, base background should have square animation
  - select emojies base don keywords
  - maybe when component is selected, it stays inverted; clicking again turns it off
  - square background should be a lot slower more often
  - color rotate sometimes
  - make it so sounds can blink as well as exponentially ramp
  - color scheme: black bg with every character a different color
  - animation: translate around in a circle with trailing transparent version + drop shadow



















Concept:
  - some mints are "the NFT"
  - other mings are web pages trying to sell the NFTs
  - sales pages take to form of CTA style adverts, news articles, social media pages, etc. -- each one linking to either each other or a target NFT
  - in all, each mint in the collection serves to hype itself up. a self-referential propaganda machine


  this NFT is HOT HOT HOT!🔥
  this NFT will moon🌛
  Don't be a sucker🍬



Things are moving fast, and if you want to make the most of this opportunity you need to pounce on it. Don't wait. Act Now. These deals won't last.





By using this website you agree to the terms...


Best viewed in Chrome X.X.XXX





TODO
  when viewed headlessly, maybe add a fake address bar to the thumbnail



MARQUEES TODO
  - generally slow down, espescially the slimmer ones
  - have more single grid components animate (instead of all of them animating)
  - split emojis up into better categories



 -->

<!DOCTYPE html>
<html translate="no" lang="en" class="notranslate">
<head>
  <meta charset="utf-8">
  <meta name="google" content="notranslate" />
  <title>$$$</title>
    <script>
      function genTokenData(projectNum) {

        const tokenId = String(projectNum * 1000000 + Math.floor(Math.random() * 1000))
        let hash = '0x'
        if (window.location.search.includes('?hash=')) {
          hash = window.location.search.slice(6)
        } else {
          for (let i = 0; i < 64; i++) {
            hash += Math.floor(Math.random() * 16).toString(16)
          }
          window.location.hash = '#' + hash

          const last10hashes = JSON.parse(localStorage.getItem('last10Hashes')) || []
          last10hashes.unshift(hash)

          localStorage.setItem('last10Hashes', JSON.stringify(last10hashes.slice(0, 10)))
        }
        return {
          hash,
          // hash: '0xfeff8806ffe0ff004900b6104392c062d40f238839029c82ed000ffff3cb2003',
          tokenId
        }
      }

      const tokenData = genTokenData(999)
      console.log(tokenData.hash)

      function LOAD_LAST(i=1) {
        const hashes = JSON.parse(localStorage.getItem('last10Hashes'))
        const hash = hashes[i]
        const newLocation = window.location.href.replace(/(\#|\?).*/, '') + '?hash=' + hash
        window.location.href = newLocation
      }
    </script>

</head>
<body>

</body>

<script src="./utils.js"></script>
<script src="./sound.js"></script>
<script src="./$.js"></script>
<script src="./globals.js"></script>
<script src="./components.js"></script>
<script src="./text.js"></script>


<script>

  function sectionContainer(child, rSpan, cSpan, h, txtH, onclick) {
    const bwc = prb(0.5) ? { bg: '#000', text: '#fff' } : { bg: '#fff', text: '#000' }
    const txtColor = bw ? bwc.text : `hsl(${txtH}deg, ${sat}%, 50%)`
    const bgColor = bw ? bwc.bg : getBgColor(h)


    const rotation = threeDRotations
      ? `perspective(500px) rotate3d(1,1,1,${lineRotation()}deg)`
      : `rotate(${lineRotation()}deg)`

    const fontStyle = prb(italicRate) ? 'italic' : 'none'


    const borderWidth = min(rSpan, cSpan) * .05

    const container = $.div(
      withBgAnimation(child, rSpan, cSpan),
      {
        class: `sectionContainer ${sectionAnimation}${rotateColor ? ' fullColorRotate' : ''}`,
        style: `
          border-style: ${borderStyle()};
          ${showBorder ? `border-width: ${borderWidth}vmin; box-sizing: border-box;` : 'border-width: 0;'}
          grid-column: span ${cSpan};
          grid-row: span ${rSpan};
          background: ${hideBg ? 'none' : bgColor};
          color: ${txtColor};
          transform: ${rotation};
          font-style: ${fontStyle};
          animation-delay: -${rnd(5)}s;
          animation-direction: ${rotateColor ?'normal' : animationDirection()};
          animation-duration: ${rotateColor ? '25' : animationDuration()}s;
        `
      }
    )

    container.onclick = onclick
    return container
  }


  function marqueeContainter(rSpan, cSpan) {
    const child = sample(content)
    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const slow = 1 + child.innerHTML.length/9
    const h = chooseHue()
    const txtH = chooseAltHue(h)


    // const slowIx = child.indexOf('slow="')
    // slowIx !== -1 ? Number(child.slice(slowIx+6, slowIx+9)) : 1

    const canShowAltAnimation = rSpan >= 2 && cSpan/rSpan >= 6 && child.innerHTML.length < 8
    const sideways = prb(sidewaysPrb) && cSpan/rSpan < 1.2

    const msgAnimation = prb(marqueeAnimationRate) && canShowAltAnimation
      ? chance(
        [1, growShrinkShort],
        [1, vSirenShort],
        [1, dance],
        [1, spin],
        [1, hSiren],
        [1, hPivot],
        [1, hFlip],
        [1, blink],
      )
      : iden

    const r = rnd(750, 1500)
    const duration = rnd(0.5, 100) * slow * speed
    const delay = rnd(duration/2) + (duration / 3)

    const showLeftRight = canShowAltAnimation && prb(0.1)
    const showTrails = showLeftRight && true

    const childEl = showLeftRight
      ? leftRight(child.cloneNode(true), {
        style: `font-size: ${height}; text-shadow: ${getShadow(txtH)};`,
        duration: r * slow * speed,
        delay,
        showTrails
      })
      : marquee(child, {
        style: `
          font-size: ${sideways ? width : height};
          text-shadow: ${getShadow(txtH)};
        `,
        direction: posOrNeg(),
        delay,
        duration,
        sideways,
        msgAnimation
      })

    return sectionContainer(childEl, rSpan, cSpan, h, txtH, () => {
      showLeftRight
        ? zoomSound({duration: r * slow * speed / 2, delay, showTrails})
        : utter(child.innerHTML, 30, 7)
    })
  }

  function animationContainer(rSpan, cSpan) {
    const child = sample(content)
    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const h = chooseHue()
    const txtH = chooseAltHue(h)

    const ignoreCharAnimation = [...emojiList, '<<<<', '>>>>'].includes(child.innerHTML)

    const animation = sample([
      dance, //
      growShrink, //
      spin, //
      hSiren, //
      vSiren, //
      hPivot, //
      vPivot, //
      vFlip, //
      hFlip, //
      updown,
      wave,
      climb,
      hexagon,
      !ignoreCharAnimation && updownChars,
      !ignoreCharAnimation && blinkChars, //
      !ignoreCharAnimation && shrinkChars, //
    ].filter(iden))

    const words = child.innerHTML.split(' ')
    const shortest = words.reduce((shortest, word) => word.length < shortest.length ? word : shortest , words[0])

    const rowSizeMax = 5.5/(child.innerHTML.length)
    const colSizeMax = 7 *(cSpan/(cols*shortest.length))

    const fontAdj = (
      emojiList.includes(child.innerHTML)
        ? 1
        : min(colSizeMax, rowSizeMax)
    ) * (animation === vPivot ? 0.5 : 1)

    const secondAnimation = prb(0.75) ? iden : sample([
      dance,
      growShrink,
      spin,
      hSiren,
      vSiren,
      hPivot,
      vPivot,
      vFlip,
      hFlip,
      updown,
      wave,
      climb,
    ])

    const primaryAnimationParams = {
      delay: rnd(3500),
      duration: rnd(750, 5000),
      direction: prb(0.5) ? 1 : -1,
      showTrails: prb(0.2)
    }

    const childEl = $.div(
      secondAnimation(
        animation(
          child.cloneNode(true),
          primaryAnimationParams
        ),
        {
          delay: rnd(3500),
          duration: rnd(750, 5000),
          showTrails: primaryAnimationParams.showTrails
        }
      ),
      {
        style: `
          font-size: ${fontAdj*100*min(rSpan/rows, cSpan/cols)}vmin;
          text-shadow: ${getShadow(h)};
          text-align: center;
          display: flex;
          align-items: center;
          justify-content: center;
        `,
      }
    )

    const playSound = () => {

      if (animation === spin) {
        smoothSound(primaryAnimationParams)
      } else if ([vPivot, hPivot, dance].includes(animation)) {
        sirenSound({
          delay: primaryAnimationParams.delay,
          duration: primaryAnimationParams.duration/2,
        })
      } else if ([growShrink, hSiren, vSiren].includes(animation)) {
        sirenSound(primaryAnimationParams)
      } else if ([hFlip, vFlip].includes(animation)) {
        flipSound(primaryAnimationParams)

      } else if (animation === blinkChars) {
        blinkCharSound(primaryAnimationParams)
      } else if ([shrinkChars, updownChars].includes(animation)) {
        shrinkCharSound(primaryAnimationParams)
      } else if (animation === hexagon) {
        hexSound(primaryAnimationParams)
      } else if (animation === climb) {
        climbSound(primaryAnimationParams)
      }
    }

    return sectionContainer(childEl, rSpan, cSpan, h, txtH, () => {
      playSound()
      if (secondAnimation !== iden || primaryAnimationParams.showTrails) playSound()
    })
  }


  function getEmojiGrid(rSpan, cSpan) {
    const divisor = rndint(1, min(rSpan/2, cSpan/2))
    return [
      max(1, int(rSpan/divisor)),
      max(1, int(cSpan/divisor))
    ]
  }

  function animationGridContainer(rSpan, cSpan) {
    const child = sample(content.filter(e => emojiList.includes(e.innerHTML)))

    if (!child) return animationContainer(rSpan, cSpan)

    const height = `calc(${100*rSpan/rows}vh)`
    const width = `calc(${100*cSpan/cols}vw)`
    const h = chooseHue()
    const txtH = chooseAltHue(h)

    const animation = chance(
      [5, growShrink],
      [4, spin],
      [3, blink],
      [3, vSiren],
      [3, hSiren],
      [3, vFlip],
      [3, hFlip],
      [1, dance],
      [1, wave],
      [1, climb],
    )

    const [r, c] = getEmojiGrid(rSpan, cSpan)


    // const words = child.innerHTML.split(' ')
    // const shortest = words.reduce((shortest, word) => word.length < shortest.length ? word : shortest , words[0])

    // const rowSizeMax = 5.5/(child.innerHTML.length)
    // const colSizeMax = 7 *(cSpan/(cols*shortest.length))

    // const fontAdj = (
    //   emojiList.includes(child.innerHTML)
    //     ? 1
    //     : min(colSizeMax, rowSizeMax)
    // ) * (animation === vPivot ? 0.5 : 1)

    // const secondAnimation = prb(0.75) ? iden : sample([
    //   dance,
    //   growShrink,
    //   spin,
    //   hSiren,
    //   vSiren,
    //   hPivot,
    //   vPivot,
    //   vFlip,
    //   hFlip,
    //   updown,
    //   wave,
    //   climb,
    // ])

    const duration = rnd(750, 5000)
    const delayFactor = rnd(0.5, 2)
    const childEl = $.div(
      times(r*c, i => animation(
        child.cloneNode(true), {
          delay: (i/(r*c))*duration*delayFactor,
          duration,
        }
      )),
      {
        class: 'animationGridContainer',
        style: `
          font-size: ${100*min(rSpan/rows, cSpan/cols)/min(r, c)}vmin;
          text-shadow: ${getShadow(h)};
          height: ${100*rSpan/rows}vh;
          width: ${100*cSpan/cols}vw;
          display: grid;
          align-items: center;
          justify-items: center;
          grid-template-rows: repeat(${r}, 1fr);
          grid-template-columns: repeat(${c}, 1fr);
        `,
      }
    )

    return sectionContainer(childEl, rSpan, cSpan, h, txtH)
  }




  function flexSection(rowCells, colCells) {
    let rCursor = 0

    const cells = {}
    times(rowCells, r => cells[r] = [])

    const findNextFilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (cells[rC][c]) return c
      }
      return colCells
    }

    const findNextUnfilledCol = (rC, cC) => {
      for (let c = cC; c < colCells; c++) {
        if (!cells[rC][c]) return c
      }

      return colCells
    }

    const marquees = []

    const colMax = prb(0.05) ? 3 : colCells
    const colMin = 12

    const rowMin = chance(
      [3, sample([24, 48])],
      [3, sample([6, 8, 12, 16])],
      [1, sample([2, 3, 4])],
      [1, 1],
    )
    const rowMax = prb(0.85) ? rowCells : rowMin


    while (rCursor < rowCells) {
      let cCursor = findNextUnfilledCol(rCursor, 0)

      while (cCursor < colCells) {
        const colsLeft = min(findNextFilledCol(rCursor, cCursor) - cCursor, colMax)
        const rowsLeft = min(rowCells - rCursor, rowMax)

        let cSpan = rndint(min(colMin, colsLeft), colsLeft)
        if (colsLeft - cSpan < colMin) cSpan = colsLeft

        const rSpan = rndint(min(rowMin, rowsLeft), max(1, rowsLeft))

        const aspectRatio = cSpan / rSpan

        marquees.push(
          aspectRatio < 1.25 && aspectRatio > 0.8 ?
            prb(0.25) ? animationContainer(rSpan, cSpan) : animationGridContainer(rSpan, cSpan) :

          aspectRatio < 2 && aspectRatio > 0.5 && prb(0.5) ?
            animationContainer(rSpan, cSpan) :

          marqueeContainter(rSpan, cSpan)
        )

        times(rSpan, r =>
          times(cSpan, c =>
            cells[rCursor+r][cCursor+c] = 1
          )
        )

        cCursor = findNextUnfilledCol(rCursor, cCursor + cSpan)
      }

      rCursor++
    }

    return $.section(
      marquees,
      {
        style: `
          width: ${100*colCells/cols}vw;
          height: ${100*rowCells/rows}vh;
          overflow: hidden;
          grid-row: span ${rowCells};
          grid-column: span ${colCells};
          display: grid;
          grid-template-rows: repeat(${rowCells}, 1fr);
          grid-template-columns: repeat(${colCells}, 1fr);
        `
      }
    )
  }




  setMetadata(content.map(c => c.innerHTML).join(' '))



  const main = $.main(
    [
      flexSection(rows, cols)
    ],
    {
      id: 'main',
      style: `
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: grid;
        grid-template-rows: repeat(${rows}, 1fr);
        grid-template-columns: repeat(${cols}, 1fr);
      `
    }
  )





  $.render($body, main)


</script>
</html>